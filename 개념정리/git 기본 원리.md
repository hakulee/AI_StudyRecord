## 📑 목차
- [1. Git의 기본 원리](#1-git의-기본-원리)
- [2. Commit과 버전](#2-commit과-버전)
- [3. HEAD](#3-head)
- [4. Git이 보는 파일의 4가지 상태](#4-Git이-보는-파일의-4가지-상태)

---

## 1. Git의 기본 원리
Git은 **분산형 버전 관리 시스템**으로, 
프로젝트의 전체 이력을 저장하는 **로컬 저장소**(Local Repository)를 각 개발자가 가질 수 있고, 
이를 **원격 저장소**(Remote Repository)와 동기화하여 협업한다. 
Git에서 중요한 개념은 크게 **3가지 작업 영역**(워킹 디렉토리, 스테이징 영역, 저장소), 
그리고 그 안에서 이뤄지는 **커밋(Commit)**과 **HEAD**이다.

![image](https://github.com/user-attachments/assets/f12780bb-8a22-4da0-9a77-c7e2b6aa7516)

1. **Working Directory (워킹 디렉토리)**
    - 실제로 코드 작성·편집·삭제 등을 수행하는 디렉토리다.
    - 코드 변경 후, 아직 커밋하지 않은 수정 사항은 이 워킹 디렉토리에만 반영되어 있다.
2. **Staging Area (스테이징 영역)**
    - 커밋하기 전에, “이번 커밋에 포함될 변경 사항”을 임시로 모아두는 공간이다.
    - 여러 파일 중 선택적으로 스테이징할 수 있어, 논리적으로 하나의 작업 단위가 되도록 커밋을 구성할 수 있다.
    - 즉, commit에 반영할 내용만 선별적으로 올리는 공간
3. **Repository (저장소)**
    - 커밋이 최종적으로 저장되는 영역이며, .git 디렉토리 내부에서 모든 버전 이력이 관리된다.
    - 여기에서 더 나아가 **로컬 저장소(Local Repository)**는 내 컴퓨터(개인 환경)에 있는 저장소를 말하고, **원격 저장소(Remote Repository)**는 팀원들이 함께 접근할 수 있는 서버(예: GitHub, GitLab 등)에 위치한 저장소를 말한다.
    - 일반적으로 각 개발자는 로컬 저장소에서 작업한 뒤, 확정된 작업 내용을 원격 저장소로 push하여 다른 사람과 공유한다. 반대로 다른 사람이 작업한 내용은 pull이나 fetch로 받아온다.
    - 즉, **로컬 저장소**는 개인 개발 환경에서의 변경 이력을 담당하며, **원격 저장소**는 협업을 위한 코드 공유와 통합 이력을 담당한다고 볼 수 있다.

---

## 2. Commit과 버전
Git에서 커밋(Commit)은 특정 시점의 변경 내용을 사진 찍듯이 스냅샷 형태로 저장하는 작업이다. 
```
 [ Commit A ] ---> [ Commit B ] ---> [ Commit C ]
   (초기버전)         (중간버전)        (최신버전)
```

---

## 3. HEAD
Git에서 HEAD는 “현재 작업 중인 버전(커밋)”을 가리키는 특별한 포인터(pointer)다. 
즉, HEAD가 어느 커밋을 향하고 있느냐에 따라 워킹 디렉토리가 해당 커밋의 상태를 반영한다. 
다음 예시들은 HEAD를 이동하여 과거 버전을 확인하고, 
다시 최신 버전으로 되돌아오는 과정을 단계별 그림으로 나타낸 것이다.
```
* HEAD가 최신 커밋(Commit C)을 가리키는 상태

┌─────────────────────┐
│  Commit C           │  ← HEAD
│ (최신 버전 상태)       │
└─────────────────────┘
         ↑
┌─────────────────────┐
│  Commit B           │
│ (중간 버전 상태)       │
└─────────────────────┘
         ↑
┌─────────────────────┐
│  Commit A           │
│ (초기 버전 상태)       │
└─────────────────────┘
```
---
```
* 과거 버전(Commit B)으로 HEAD 이동

┌─────────────────────┐
│  Commit C           │
│ (HEAD가 벗어난 상태)   │
└─────────────────────┘
         ↑
┌─────────────────────┐
│  Commit B           │  ← HEAD
│ (과거 버전 상태)       │
└─────────────────────┘
         ↑
┌─────────────────────┐
│  Commit A           │
│ (초기 버전 상태)       │
└─────────────────────┘
```

---
## 4. Git이 보는 파일의 4가지 상태

### Git 파일 상태 및 전환 요약

Git으로 관리되는 파일은 항상 **상태(status)**를 가지며, 이는 Git이 파일의 변동사항을 어떻게 추적하는지를 나타냅니다.

![image.png](attachment:96b13f96-c4c7-4333-8929-bdf45eb6d185:image.png)

### 1. 파일의 기본 상태

- **Untracked 상태:**
    
    Git이 해당 파일을 추적하지 않는 상태입니다.
    
    *예시:* 새로 생성한 파일에 대해 아직 `git add`를 수행하지 않은 경우.
    
- **Tracked 상태:**
    
    Git이 파일을 추적하는 상태로, 이후에는 다음 3가지 세부 상태로 나뉩니다.
    
    1. **Staged 상태:**
        
        파일의 변경사항이 스테이징 영역(인덱스)에 올라온 상태입니다.
        
        *예시:* 새 파일에 내용을 추가 후 `git add`를 하거나, 이미 커밋된 파일의 변경사항을 `git add`로 스테이징한 경우.
        
    2. **Unmodified 상태:**
        
        작업 디렉터리의 파일 내용이 최신 커밋과 동일하여 변경사항이 없는 상태입니다.
        
        *예시:* 커밋 직후 모든 파일은 이 상태가 됩니다.
        
    3. **Modified 상태:**
        
        최신 커밋에 비해 파일 내용에 변경이 발생한 상태입니다.
        
        *예시:* 커밋 후 파일을 수정했지만 아직 `git add`를 하지 않은 경우.
        

### 2. 상태 전환과 관련된 작업

- **Add the file:**
    - *동작:* `git add` 명령 실행
    - *전환:* Untracked 상태의 파일이 Staged 상태로 전환됨
- **Edit the file:**
    - *동작:* 파일 수정
    - *전환:* Unmodified 상태의 파일이 Modified 상태로 전환됨
- **Stage the file:**
    - *동작:* 수정된 파일에 대해 `git add` 실행
    - *전환:* Modified 상태의 파일이 Staged 상태로 전환됨
- **Remove the file:**
    - *동작:* 파일 삭제
    - *전환:* 파일이 Git의 추적 대상에서 제외됨 (삭제된 파일로 인식)
- **Commit:**
    - *동작:* `git commit` 명령 실행
    - *전환:* Staged 상태의 파일들이 커밋에 반영되어, 이후 모두 Unmodified 상태가 됨
